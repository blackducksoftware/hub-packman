import groovy.json.JsonBuilder
import groovy.json.JsonSlurper

import com.github.mustachejava.Mustache
import com.github.mustachejava.DefaultMustacheFactory
import com.github.mustachejava.MustacheFactory
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'org.springframework.boot:spring-boot-gradle-plugin:1.5.2.RELEASE'
        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.8.1'
		classpath 'com.github.spullara.mustache.java:compiler:0.8.18'
    }
}

plugins {
    id 'groovy'
    id 'eclipse'
    id 'maven'
    id 'org.springframework.boot' version '1.5.2.RELEASE'
    id 'jacoco'
    id 'com.github.kt3k.coveralls' version '2.8.1'
    id 'com.github.hierynomus.license' version '0.14.0'
}

tasks.withType(JavaCompile) { options.encoding = 'UTF-8' }
tasks.withType(GroovyCompile) { options.encoding = 'UTF-8' }

group = 'com.blackducksoftware.integration'

// Detect version
version = '1.1.0-SNAPSHOT'

// Human's must change this here and in DetectProperties for every update
final String gradleInspectorVersion = '0.2.1'
final String nugetInspectorVersion = '2.0.0'

final String gradleAirgapPath = "${buildDir}/libs/airgap/gradle"
final String nugetAirgapPath = "${buildDir}/libs/airgap/nuget"

// BuildInfo - A json payload usable by detect for information from the build
JsonBuilder jsonBuilder = new JsonBuilder()
jsonBuilder {
    detect version
}
final def buildConfigurationFile = new File("${projectDir}/src/main/resources/buildInfo.json")
buildConfigurationFile.delete()
buildConfigurationFile << jsonBuilder.toPrettyString()

// the override.snaphot property should be set to true for a CI build so
// that the version is omitted from a snapshot build artifact
if (version.contains('SNAPSHOT') && "true" == project.findProperty('override.snapshot')) {
    version = 'latest-SNAPSHOT'
}

sourceCompatibility = 1.7
targetCompatibility = 1.7

build {
	dependsOn 'generateProperties'
	
    finalizedBy 'updateAirgapDependencies'
    
    doLast {
        def shellScriptTemplateFile = new File("${projectDir}/src/main/resources/hub-detect-sh")
        def shellScriptContents = shellScriptTemplateFile.getText('UTF-8')
        if (!version.contains('SNAPSHOT')) {
            String latestReleaseVersion = 'DETECT_LATEST_RELEASE_VERSION=\\${DETECT_LATEST_RELEASE_VERSION:-' + "${version}" + '}\n'
            shellScriptContents = shellScriptContents.replaceFirst("DETECT_LATEST_RELEASE_VERSION=\\S*\n", latestReleaseVersion)
            shellScriptTemplateFile.delete()
            shellScriptTemplateFile << shellScriptContents
        }
        def shellScriptFile = new File("${buildDir}/hub-detect.sh")
        shellScriptFile.delete()
        shellScriptFile << shellScriptContents
        shellScriptFile.setExecutable(true)
    }
}

repositories {
    mavenLocal()
    mavenCentral()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
}

configurations {
    airgapConfig
}

dependencies {
    compile 'com.blackducksoftware.integration:hub-detect-model:0.0.3'
    compile 'com.blackducksoftware.integration:hub-common:14.4.0'
    compile 'org.springframework.boot:spring-boot-starter'
    compile 'org.apache.maven.shared:maven-invoker:3.0.0'
    compile 'com.esotericsoftware.yamlbeans:yamlbeans:1.11'
    compile 'com.moandjiezana.toml:toml4j:0.7.1'
    compile 'org.codehaus.groovy:groovy-all:2.4.11'

    compile 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.9.0'
    compile 'com.fasterxml.jackson.core:jackson-databind:2.9.0'
    compile 'com.fasterxml.jackson.core:jackson-annotations:2.9.0'
    
    airgapConfig "com.blackducksoftware.integration:integration-gradle-inspector:${gradleInspectorVersion}"

    testCompile 'org.springframework.boot:spring-boot-starter-test'
}

springBoot { mainClass = 'com.blackducksoftware.integration.hub.detect.Application' }

jacocoTestReport {
    reports { xml.enabled = true }
}

license {
    header = file('HEADER')
    ext.year = Calendar.getInstance().get(Calendar.YEAR)
    ignoreFailures = true
    includes (["**/*.groovy", "**/*.java"])
    exclude "/src/test/*"
}

tasks.licenseMain.dependsOn(licenseFormatMain)

void fetchFile(File outputFile, String url) {
    if (outputFile.exists()) {
        return
    }
    if (!outputFile.getParentFile().exists()) {
        outputFile.getParentFile().mkdirs()
    }
    new URL(url).withInputStream{ i -> outputFile.withOutputStream{ it << i }}
}

//////////// Air gap dependencies ////////////
task cleanAirgapDependencies(type: Delete) {
    delete fileTree(gradleAirgapPath)
}

task downloadGradleAirgapDependencies(type: Copy) {
    from configurations.airgapConfig
    into gradleAirgapPath
}

task downloadNugetAirgapDependencies {
    doLast {
        final def nugetInspectorUrl = "https://www.nuget.org/api/v2/package/IntegrationNugetInspector/${nugetInspectorVersion}"
        fetchFile(new File(nugetAirgapPath, 'nugetInspector.nupkg'), nugetInspectorUrl)
    }
}

task updateAirgapDependencies {
    dependsOn cleanAirgapDependencies, downloadGradleAirgapDependencies, downloadNugetAirgapDependencies
}

//////////// Propert file generation ////////////
class PropertiesFile {
	List<Group> groups = []
}

class Group {
	String name
	String groupVariableName
	List<Property> properties = []
}

class Property {
	String name
	String propertyVariableName
	String description
	String defaultValue
	String type = 'String'
	String value
}

task generateProperties {
		println 'Generating properties'
		MustacheFactory mf = new DefaultMustacheFactory()
		JsonSlurper jsonSlurper = new JsonSlurper()
		File propertiesJosnFile = new File("${projectDir}/src/main/resources/properties.json".replace('/', File.separator))
		File applicationPropertiesTemplateFile = new File("${projectDir}/src/main/resources/mustache/application.properties.mustache".replace('/', File.separator))
		File applicationPropertiesFile = new File("${projectDir}/src/main/resources/application.properties".replace('/', File.separator))
		File detectPropertiesTemplateFile = new File("${projectDir}/src/main/resources/mustache/DetectProperties.groovy.mustache".replace('/', File.separator))
		File detectPropertiesFile = new File("${projectDir}/src/main/groovy/com/blackducksoftware/integration/hub/detect/DetectProperties.groovy".replace('/', File.separator))
		
		def propertiesFile = new PropertiesFile()
		def properties = jsonSlurper.parseText(propertiesJosnFile.getText(StandardCharsets.UTF_8.toString()))
		properties.each { groupName, propertyGroup ->
			def group = new Group([name: groupName])
			group.groupVariableName = "GROUP_${group.name.toUpperCase().replace(' ', '_')}"
			propertyGroup.each { propertyName, jsonProprety ->
				def property = new Property(jsonProprety)
				property.name = propertyName
				if (property.name.startsWith('logging')) {
					property.value = property.defaultValue
				}
				property.propertyVariableName = convertToVariableName(property.name)
				group.properties.add(property)
			}
			propertiesFile.groups.add(group)
		}
		
		Mustache applicationPropertiesMustache = mf.compile(applicationPropertiesTemplateFile.getCanonicalPath())
		applicationPropertiesMustache.execute(new FileWriter(applicationPropertiesFile), propertiesFile).flush();
		
		Mustache detectPropertiesMustace = mf.compile(detectPropertiesTemplateFile.getCanonicalPath())
		detectPropertiesMustace.execute(new FileWriter(detectPropertiesFile), propertiesFile).flush();
}

private String convertToVariableName(String propertyName) {
	if (!propertyName?.trim()) {
		return null
	}
	List<String> segments = propertyName.split('\\.').collect{ it.capitalize() }
	if (segments.isEmpty()) {
		return null
	}
	segments.remove(0)
	segments[0] = segments[0].toLowerCase()
	
	segments.join('')
}


